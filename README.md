# proyectoDAM
Proyecto final CS Desarrollo Aplicaciones Multiplataforma

Semana 12-18 Abril
  - Los primeros cursos de HTML5 y CSS3 son muy básicos. Empieza un poco con la historia y la base teórica de cómo se ha llegado a lo que es a día de hoy pero no hay mucho contenido que no haya visto/practicado en estos dos años de clase (estructura de una página web, etiquetas y atributos, formularios, tablas, fieldsets), más allá de alguna etiqueta suelta como <iframe> o alguna etiqueta multimedia. En cuanto al CSS, aunque sea un curso de aprendizaje literalmente desde 0, lo volveré a repetir un par de veces para afianzar conceptos ya que, sinceramente, el CSS es algo que se me atraganta, y quiero afianzar más una base antes de meterme de pleno en un framework para el frontend. Los ejemplos de tareas del curso considero que son bastante sencillos/básicos, teniendo en cuenta que es un curso desde 0.
  
  - JavaScript: también empieza desde 0, explicando un poco la base teórica y los distintos conceptos básicos que hay que manejar (runtime, asincronía, paralelismo, event loop, etc). Por ahora, tampoco he encontrado nada nuevo o que me resulte extraño o diferente al contenido del ciclo, aunque a nivel personal me interesa bastante todo lo relacionado con JavaScript ya que es muy utilizado y requerido en el mundo laboral y lo estoy tratando bastante en las prácticas. Aún así, voy cogiendo más soltura con los proyectos que tengo que realizar en la empresa y podré dedicarle más tiempo y esfuerzo al proyecto en estas semanas para los siguientes cursos que son totalmente desconocidos para mí.
  
 Semana 25 Abril - 2 Mayo
  
  - JavaScript: el curso sigue siendo de aspectos básicos (primitivas, estructuras y operaciones con datos, diferencias entre declaraciones de funciones y llamadas a ellas). Me pareció interesante el tema de bind/call/apply para ver el funcionamiento de this en JavaScript, estando acostumbrado a la POO en Java/C#, y como poder tratarlo en tiempo de ejecución. El tema de orientación a objetos, instancia y propiedades y acceso a ellas no es nada nuevo, similar a lenguajes ya vistos, aunque lo que sí que no conocía era el tema de los prototipos (__proto__) para herencias.
  El tema de control de flujo es básico, comparaciones con true y false, funcionamiento de switch y orden de toma de deciones del llamado "Coercion Algorithm' para hacer las comprobaciones de una comparación. En cuanto al uso de las iteraciones, tampoco nada nuevo del funcionamiento de los bucles, similar a otros lenguajes ya vistos.
  En cuanto al último de tema de funcionamiento del navegador con JavaScript, sí que me pareció interesante cómo poder manejar y entender cómo funcionan los xml/json y convertirlos para poder tratar los datos de una web o API, dentro de las miles de líneas de código que tienen.
  Algo que sí me gustaría en este tema es que hubiese algún planteamiento de ejercicios más allá de ejemplos hechos a lo largo del vídeo para poder practicar, como era el caso del primer tema de HTML/CSS, donde aunque los ejercicios fueran básicos (teniendo en cuenta que se parte de 0), es una manera diferente de practicar aparte de seguir los ejemplos que va haciendo sobre la marcha o que coge directamente de la documentación oficial para ver cómo funcionan.
  
  - Vue.js: entrando un poco ya en materia nueva, el tema de vue.js y tener la opción de utilizar un framework que te facilite y mejore la creación del front-end de tu  web sin la "necesidad" de crearlo todo desde 0 con simple CSS abre un abanico de posibilidades a la hora de programar. Este tema ya tiene algunos ejemplos prácticos con los que sí poder practicar y poder familiarizarme con el framework, además de ir subiendo algo útil para el seguimiento sin ser ejercicios o comprobaciones sueltas.
  
 Semana 2 Mayo - 9 Mayo
  
  - Vue.js: avanzando con los vídeos y creado el proyecto, el inicio (así como a varios usuarios que han puesto un comentario en las respuestas del vídeo) me parece un poco confuso una vez te pones con la parte práctica. Instaladas dependencias de npm, node.js y babel. Interesante este último, transpilador para "traducir" ecmascript a javascript compatible con cualquier navegador moderno.
  Imagino que es normal, pero veo demasiada diferencia entre la enseñanza desde 0 de los cursos de HTML y CSS comparado con éste (también es un profesor distinto). Como ya dije, en las respuestas veo que no soy el único y hay desconcierto a la hora de realizar los primeros pasos (creación del proyecto, primer componente, qué ha hecho el profesor para llegar hasta ahí, etc.) 
  
  
Semana 9 Mayo - 16 Mayo
    
  - Vue.js: siguiendo con el curso, el tema del ciclo de vida de los componentes supongo que es algo lógico en cualquier o casi cualquier parte de la programación, que todo siga un orden dependiendo en qué fase se encuentre. En cuanto a la comunicación entre componentes, desde el padre al hijo se hace mediante las propiedades que el hijo hereda y en el caso contrario, aunque no es lo habitual, para comunicarse desde un hijo al padre se haría mediante la emisión de eventos, aunque solo si se quiere comunicar con sólo un nivel superior. Sobre los componentes asíncronos, vue nos permite la posibilidad de cargar nuestros componentes de forma asíncrona, o bajo demanda; básicamente, cargarlos sólo cuando los necesitemos y no siempre que se ejecute nuestra aplicación para ahorrar recursos.
  He instalado pug en el proyecto, que es una alternativa para generar el HTML de una forma más corta y utilizando una sintaxis más simple. Además, se pueden utilizar atributos, filtros, módulos e interpolaciones propias de pug. Me ha parecido interesante lo que he entendido del tema de bindings y asociar un elemento del componente a alguna parte del frontend, como puede ser un nombre o un email.
  
  - Git: instalación de herramientas de trabajo de git y creación del primer repositorio local. Explicación básica de las 3 fases que experimenta un archivo (working directory, staging y commit). Comando git diff para saber qué ha cambiado en un fichero y uso de tkdiff como herramienta más visual para ver los cambios. Explicación de cómo utilizar el git diff para ver los cambios dependiendo de la fase en la que se encuentre el fichero, ya que el git diff no va a comprobar cambios de un fichero que está en el working directory y en el área de staging, pero sí lo hará con los cambios de un fichero en el working directory y en el área de commit (lo ejemplifica bastante bien simulando que cada estado es una caja a la que se va moviendo el fichero al hacer git add y git commit). Para comparar cambios entre un fichero que está en el working directory y otro que está staged usaremos el comando git diff --staged.
  
  - Git remoto: conexión a un repositorio remoto desde comandos de consola git bash. Git pull para descargar archivos del repositorio al que hemos realizado la conexión con git fetch (en el ejemplo estamos el proyecto: https://github.com/sharkdp/bat y git push para subir archivos al repositorio (aunque actualmente estamos trabajando en local). En otro ejemplo se usa git clone directamente del repositorio, con lo que las funciones git init, git fetch y pull están implícitos.
  
  En cuanto a deshacer cambios que hemos hecho, podemos "retirar" un fichero que ya fue aprobado y está en área de commit y devolverlo al working directory con el comando checkout, mientras que para "enviar" un fichero del área de staging tras hacer un git add al working directory se usa el comando reset. Con el git checkout podemos añadir el identificador -- para referirnos a un archivo o un grupo de archivos (por ejemplo si un archivo se llama master y sólo queremos traer de vuelta ese archivo, ya que, por defecto, la rama principal del repositorio se llamará master a no ser que lo modifiquemos). 
  - Ramas de git (branches): muy interesante este tema, dando la posibilidad de, a partir de un código base, que surjan varios "experimentos" con los que hacer pruebas, testear métodos o funciones y, si llegan a ser aprobados, fusionarlos con la rama principal. Ideal para trabajos en equipo.
   Para crear nuevas ramas utilizamos "git branch 'nombrerama' 'rama de partida'" y para movernos a esa rama utilizamos git checkout 'nombrerama'. Una vez terminado y si queremos aprobar los cambios que hemos realizado en nuestra rama y añadirlos a la rama principal se usa el comando git merge 'ramaorigen' 'ramadestino'. Para borrar una rama se utiliza el comando git branch con el modificador -d 'nombrerama'. Me pareció interesante la funcionalidad de git blame, para encontrar al autor de un cambio (deseado o indeseado), por ejemplo, para saber quién ha modificado un fichero en concreto, líneas de código en concreto: git blame -L 6,8 src/output.rs.
  También creo que es muy importante el tema de las etiquetas, sobre todo para las distintas versiones que puede tener mi proyecto y la información que pueden albergar, pudiendo apuntar, por ejemplo, a una versión donde tenga cambios verdaderamente importantes y que deberían tener en cuenta. Lo último a descatar es el uso del git stash, que nos hace una especie de "copia temporal" o foto de la que podemos volver a obtener los datos de ese momento.
  Personalmente, pienso que git (GitHub/GitLab) es una herramienta imprescindible para cualquier programador, dadas todas las funcionalidades que ofrece tanto individual como colectivamente, además de las facilidades para poder tener acceso a tu repositorio prácticamente en cualquier dispositivo o trabajar directamente en local.
  
  - Curso git vs curso vue.js:
    Veo que hay una diferencia ABISMAL a la hora de la enseñanza del curso. Puedo entender que vue.js es un campo que puede extenderse mucho (aunque git también tiene lo suyo) y hay más conceptos que tratar a la hora de explicarlo desde cero, pero partiendo de que el curso es para personas que tienen 0 experiencia en esos campos, lo estoy pasando realmente mal con el curso de vue.js: apenas puedo ejecutar el proyecto sin errores, cada vez que intento seguir los vídeos de las explicaciones el código es distinto de un vídeo a otro, o incluso de un fotograma a otro, crea componentes de la nada, copia y pega código que ni idea de donde lo saca ni lo enseña/explica. Honestamente, está siendo una muy mala experiencia y no estoy logrando aprender nada (y lo que más me asusta es que los cursos de node.js y express los da el mismo profesor). 
  Por otra parte, el curso de git, aunque el profesor se ponga a tirar comandos sin parar, marca una buena base de para qué es cada uno, aparte de la explicación en vídeo tiene los apuntes resumidos en la descripción donde explica incluso más algunos detalles que se han podido pasar y, vuelvo a decir, aunque es un curso básico de git, la explicación de cada comando o de cada paso que va a seguir está muy bien detallada, todo lo contrario que el de vue, en el que me da la impresión de que, como me dijiste en la anterior revisión, da por triviales cosas que, al menos para mí, no lo están siendo y por mucho que lo intente no consigo avanzar. 
  
  En el caso del curso de git, los ejemplos prácticos que he subido son básicamente jugar un poco con los comandos básicos, ver las modificaciones y como funcionan los tres estados de los ficheros, clonado de repositorios remotos, funciones con ramas (crear, moverte, eliminar).
  
  Semana 16 Mayo - 23 Mayo
    
    - MongoDB: explicaciones iniciales de su histórico, por qué nacen las bases de datos noSQL, formato JSON, ventajas y desventajas entre SQL y noSQL.
  Instalación de servicios mongoDB, interfaz y consola mongosh en Windows, aunque en el vídeo se utiliza MacOS.
  Comandos de creación y borrado de bases de datos, inserción de colecciones y elementos (denominados documentos, en formato JSON). Interesante que al insertar datos en una colección, si no agregas un identificador mondoDB se encarga de asignarle un id propio (ObjectID) y único.
  La primera práctica es básica, de inserción de datos con propiedades. No puedo subir nada ya que no es un proyecto como tal, más que comandos en el shell de mongo.
  
  Comandos de inserción: db.nombrecoleccion.insertOne({ documento JSON }). También tenemos la posibilidad hacer una inserción múltiple con insertMany en lugar de insertOne. Para consultar los datos que contiene una colección se usa el comando db.nombrecoleccion.find(). Para eliminar un registro se usa el comando db.nombrecoleccion.deleteOne({condicion}). También es posible usar deleteMany para el borrado de varios registros, donde se borrará el documento que cumpla la condición (si se usa deleteOne y hay varios documentos que cumplan la condición se borrará el primero que encuentre). Para la actualización de registros, hay 3 maneras, updateOne, updateMany o replaceOne. En los dos primeros hay que introducir 2 documentos JSON, uno con el filtro para encontrar el/los registros que queremos actualizar y en un segundo documento las propiedades que se actualizarán basados en la palabra reservada $set. Si usamos replaceOne, también hay que introducir dos documentos JSON como parámetros, pero este método directamente, como su nombre indica, reemplaza el documento que encuentra con el filtro que introducimos como primer parámetrp y lo reemplaza por el documento json que pasamos como segundo parámetro.
  
  
  
  
  
  
  
  
