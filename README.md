# proyectoDAM
Proyecto final CS Desarrollo Aplicaciones Multiplataforma

Semana 12-18 Abril
  - Los primeros cursos de HTML5 y CSS3 son muy básicos. Empieza un poco con la historia y la base teórica de cómo se ha llegado a lo que es a día de hoy pero no hay mucho contenido que no haya visto/practicado en estos dos años de clase (estructura de una página web, etiquetas y atributos, formularios, tablas, fieldsets), más allá de alguna etiqueta suelta como <iframe> o alguna etiqueta multimedia. En cuanto al CSS, aunque sea un curso de aprendizaje literalmente desde 0, lo volveré a repetir un par de veces para afianzar conceptos ya que, sinceramente, el CSS es algo que se me atraganta, y quiero afianzar más una base antes de meterme de pleno en un framework para el frontend. Los ejemplos de tareas del curso considero que son bastante sencillos/básicos, teniendo en cuenta que es un curso desde 0.
  
  - JavaScript: también empieza desde 0, explicando un poco la base teórica y los distintos conceptos básicos que hay que manejar (runtime, asincronía, paralelismo, event loop, etc). Por ahora, tampoco he encontrado nada nuevo o que me resulte extraño o diferente al contenido del ciclo, aunque a nivel personal me interesa bastante todo lo relacionado con JavaScript ya que es muy utilizado y requerido en el mundo laboral y lo estoy tratando bastante en las prácticas. Aún así, voy cogiendo más soltura con los proyectos que tengo que realizar en la empresa y podré dedicarle más tiempo y esfuerzo al proyecto en estas semanas para los siguientes cursos que son totalmente desconocidos para mí.
  
 Semana 25 Abril - 2 Mayo
  
  - JavaScript: el curso sigue siendo de aspectos básicos (primitivas, estructuras y operaciones con datos, diferencias entre declaraciones de funciones y llamadas a ellas). Me pareció interesante el tema de bind/call/apply para ver el funcionamiento de this en JavaScript, estando acostumbrado a la POO en Java/C#, y como poder tratarlo en tiempo de ejecución. El tema de orientación a objetos, instancia y propiedades y acceso a ellas no es nada nuevo, similar a lenguajes ya vistos, aunque lo que sí que no conocía era el tema de los prototipos (__proto__) para herencias.
  El tema de control de flujo es básico, comparaciones con true y false, funcionamiento de switch y orden de toma de deciones del llamado "Coercion Algorithm' para hacer las comprobaciones de una comparación. En cuanto al uso de las iteraciones, tampoco nada nuevo del funcionamiento de los bucles, similar a otros lenguajes ya vistos.
  En cuanto al último de tema de funcionamiento del navegador con JavaScript, sí que me pareció interesante cómo poder manejar y entender cómo funcionan los xml/json y convertirlos para poder tratar los datos de una web o API, dentro de las miles de líneas de código que tienen.
  Algo que sí me gustaría en este tema es que hubiese algún planteamiento de ejercicios más allá de ejemplos hechos a lo largo del vídeo para poder practicar, como era el caso del primer tema de HTML/CSS, donde aunque los ejercicios fueran básicos (teniendo en cuenta que se parte de 0), es una manera diferente de practicar aparte de seguir los ejemplos que va haciendo sobre la marcha o que coge directamente de la documentación oficial para ver cómo funcionan.
  
  - Vue.js: entrando un poco ya en materia nueva, el tema de vue.js y tener la opción de utilizar un framework que te facilite y mejore la creación del front-end de tu  web sin la "necesidad" de crearlo todo desde 0 con simple CSS abre un abanico de posibilidades a la hora de programar. Este tema ya tiene algunos ejemplos prácticos con los que sí poder practicar y poder familiarizarme con el framework, además de ir subiendo algo útil para el seguimiento sin ser ejercicios o comprobaciones sueltas.
  
 Semana 2 Mayo - 9 Mayo
  
  - Vue.js: avanzando con los vídeos y creado el proyecto, el inicio (así como a varios usuarios que han puesto un comentario en las respuestas del vídeo) me parece un poco confuso una vez te pones con la parte práctica. Instaladas dependencias de npm, node.js y babel. Interesante este último, transpilador para "traducir" ecmascript a javascript compatible con cualquier navegador moderno.
  Imagino que es normal, pero veo demasiada diferencia entre la enseñanza desde 0 de los cursos de HTML y CSS comparado con éste (también es un profesor distinto). Como ya dije, en las respuestas veo que no soy el único y hay desconcierto a la hora de realizar los primeros pasos (creación del proyecto, primer componente, qué ha hecho el profesor para llegar hasta ahí, etc.) 
  
  
Semana 9 Mayo - 16 Mayo
    
  - Vue.js: siguiendo con el curso, el tema del ciclo de vida de los componentes supongo que es algo lógico en cualquier o casi cualquier parte de la programación, que todo siga un orden dependiendo en qué fase se encuentre. En cuanto a la comunicación entre componentes, desde el padre al hijo se hace mediante las propiedades que el hijo hereda y en el caso contrario, aunque no es lo habitual, para comunicarse desde un hijo al padre se haría mediante la emisión de eventos, aunque solo si se quiere comunicar con sólo un nivel superior. Sobre los componentes asíncronos, vue nos permite la posibilidad de cargar nuestros componentes de forma asíncrona, o bajo demanda; básicamente, cargarlos sólo cuando los necesitemos y no siempre que se ejecute nuestra aplicación para ahorrar recursos.
  He instalado pug en el proyecto, que es una alternativa para generar el HTML de una forma más corta y utilizando una sintaxis más simple. Además, se pueden utilizar atributos, filtros, módulos e interpolaciones propias de pug. Me ha parecido interesante lo que he entendido del tema de bindings y asociar un elemento del componente a alguna parte del frontend, como puede ser un nombre o un email.
  
  - Git: instalación de herramientas de trabajo de git y creación del primer repositorio local. Explicación básica de las 3 fases que experimenta un archivo (working directory, staging y commit). Comando git diff para saber qué ha cambiado en un fichero y uso de tkdiff como herramienta más visual para ver los cambios. Explicación de cómo utilizar el git diff para ver los cambios dependiendo de la fase en la que se encuentre el fichero, ya que el git diff no va a comprobar cambios de un fichero que está en el working directory y en el área de staging, pero sí lo hará con los cambios de un fichero en el working directory y en el área de commit (lo ejemplifica bastante bien simulando que cada estado es una caja a la que se va moviendo el fichero al hacer git add y git commit). Para comparar cambios entre un fichero que está en el working directory y otro que está staged usaremos el comando git diff --staged.
  
  - Git remoto: conexión a un repositorio remoto desde comandos de consola git bash. Git pull para descargar archivos del repositorio al que hemos realizado la conexión con git fetch (en el ejemplo estamos el proyecto: https://github.com/sharkdp/bat y git push para subir archivos al repositorio (aunque actualmente estamos trabajando en local). En otro ejemplo se usa git clone directamente del repositorio, con lo que las funciones git init, git fetch y pull están implícitos.
  
  En cuanto a deshacer cambios que hemos hecho, podemos "retirar" un fichero que ya fue aprobado y está en área de commit y devolverlo al working directory con el comando checkout, mientras que para "enviar" un fichero del área de staging tras hacer un git add al working directory se usa el comando reset. Con el git checkout podemos añadir el identificador -- para referirnos a un archivo o un grupo de archivos (por ejemplo si un archivo se llama master y sólo queremos traer de vuelta ese archivo, ya que, por defecto, la rama principal del repositorio se llamará master a no ser que lo modifiquemos). 
  - Ramas de git (branches): muy interesante este tema, dando la posibilidad de, a partir de un código base, que surjan varios "experimentos" con los que hacer pruebas, testear métodos o funciones y, si llegan a ser aprobados, fusionarlos con la rama principal. Ideal para trabajos en equipo.
   Para crear nuevas ramas utilizamos "git branch 'nombrerama' 'rama de partida'" y para movernos a esa rama utilizamos git checkout 'nombrerama'. Una vez terminado y si queremos aprobar los cambios que hemos realizado en nuestra rama y añadirlos a la rama principal se usa el comando git merge 'ramaorigen' 'ramadestino'. Para borrar una rama se utiliza el comando git branch con el modificador -d 'nombrerama'. Me pareció interesante la funcionalidad de git blame, para encontrar al autor de un cambio (deseado o indeseado), por ejemplo, para saber quién ha modificado un fichero en concreto, líneas de código en concreto: git blame -L 6,8 src/output.rs.
  También creo que es muy importante el tema de las etiquetas, sobre todo para las distintas versiones que puede tener mi proyecto y la información que pueden albergar, pudiendo apuntar, por ejemplo, a una versión donde tenga cambios verdaderamente importantes y que deberían tener en cuenta. Lo último a descatar es el uso del git stash, que nos hace una especie de "copia temporal" o foto de la que podemos volver a obtener los datos de ese momento.
  Personalmente, pienso que git (GitHub/GitLab) es una herramienta imprescindible para cualquier programador, dadas todas las funcionalidades que ofrece tanto individual como colectivamente, además de las facilidades para poder tener acceso a tu repositorio prácticamente en cualquier dispositivo o trabajar directamente en local.
  
  - Curso git vs curso vue.js:
    Veo que hay una diferencia ABISMAL a la hora de la enseñanza del curso. Puedo entender que vue.js es un campo que puede extenderse mucho (aunque git también tiene lo suyo) y hay más conceptos que tratar a la hora de explicarlo desde cero, pero partiendo de que el curso es para personas que tienen 0 experiencia en esos campos, lo estoy pasando realmente mal con el curso de vue.js: apenas puedo ejecutar el proyecto sin errores, cada vez que intento seguir los vídeos de las explicaciones el código es distinto de un vídeo a otro, o incluso de un fotograma a otro, crea componentes de la nada, copia y pega código que ni idea de donde lo saca ni lo enseña/explica. Honestamente, está siendo una muy mala experiencia y no estoy logrando aprender nada (y lo que más me asusta es que los cursos de node.js y express los da el mismo profesor). 
  Por otra parte, el curso de git, aunque el profesor se ponga a tirar comandos sin parar, marca una buena base de para qué es cada uno, aparte de la explicación en vídeo tiene los apuntes resumidos en la descripción donde explica incluso más algunos detalles que se han podido pasar y, vuelvo a decir, aunque es un curso básico de git, la explicación de cada comando o de cada paso que va a seguir está muy bien detallada, todo lo contrario que el de vue, en el que me da la impresión de que, como me dijiste en la anterior revisión, da por triviales cosas que, al menos para mí, no lo están siendo y por mucho que lo intente no consigo avanzar. 
  
  En el caso del curso de git, los ejemplos prácticos que he subido son básicamente jugar un poco con los comandos básicos, ver las modificaciones y como funcionan los tres estados de los ficheros, clonado de repositorios remotos, funciones con ramas (crear, moverte, eliminar).
  
  Semana 16 Mayo - 23 Mayo
    
   - MongoDB: explicaciones iniciales de su histórico, por qué nacen las bases de datos noSQL, formato JSON, ventajas y desventajas entre SQL y noSQL.
  Instalación de servicios mongoDB, interfaz y consola mongosh en Windows, aunque en el vídeo se utiliza MacOS.
  Comandos de creación y borrado de bases de datos, inserción de colecciones y elementos (denominados documentos, en formato JSON). Interesante que al insertar datos en una colección, si no agregas un identificador mondoDB se encarga de asignarle un id propio (ObjectID) y único.
  La primera práctica es básica, de inserción de datos con propiedades. No puedo subir nada ya que no es un proyecto como tal, más que comandos en el shell de mongo.
  
  Comandos de inserción: db.nombrecoleccion.insertOne({ documento JSON }). También tenemos la posibilidad hacer una inserción múltiple con insertMany en lugar de insertOne. Para consultar los datos que contiene una colección se usa el comando db.nombrecoleccion.find(). Para eliminar un registro se usa el comando db.nombrecoleccion.deleteOne({condicion}). También es posible usar deleteMany para el borrado de varios registros, donde se borrará el documento que cumpla la condición (si se usa deleteOne y hay varios documentos que cumplan la condición se borrará el primero que encuentre). Para la actualización de registros, hay 3 maneras, updateOne, updateMany o replaceOne. En los dos primeros hay que introducir 2 documentos JSON, uno con el filtro para encontrar el/los registros que queremos actualizar y en un segundo documento las propiedades que se actualizarán basados en la palabra reservada $set. Si usamos replaceOne, también hay que introducir dos documentos JSON como parámetros, pero este método directamente, como su nombre indica, reemplaza el documento que encuentra con el filtro que introducimos como primer parámetrp y lo reemplaza por el documento json que pasamos como segundo parámetro.
  Al contrario de las bases de datos SQL, las noSQL son Schemaless, y no tienen que seguir el 'esquema' de reglas relacionadas con el tipo de información que almacena. Tiene ventajas y desventajas, como sacrificar un poco de control del tipo de datos por ganar algo de flexibilidad a la hora de guardar documentos. También existen los documentos referenciados, en los que podemos "llamarlos" por su identificador y podemos acceder a sus datos.
  Para consultar documentos tenemos el comando db.nombrecoleccion.find(), al que podemos pasar un documento json como parámetro opcional que funcionará como filtro para buscar. Añadiendo .pretty() al final, nos mostrará los resultados con un formateo más amigable y fácil de leer.
  Por último, tenemos los índices, que tenemos que añadir manualmente para cada registro, aunque se pueden crear índices compuestos sobre varios campos. Si no hubiera índices, a la hora de realizar cualquier consulta, mongoDB tendría que analizar absolutamente todos los datos, incluso para buscar un dato en concreto. Resumidamente, se usan como un filtro más para evitar que las consultas sean tan costosas y optimizar el rendimiento de nuestra base de datos.
  En resumen, buen curso, sencillo, dejando claros los conceptos básicos de cómo gestionar una base de datos. Desconozco si en Mac también está disponible, pero en Windows mongoDB tiene un programa con interfaz gráfica (MongoDB Compass) que es más visual y accesible, aunque he realizado el curso con comandos en la consola de mongodb (mongosh) para seguir el ritmo del profesor.
  
  - Express y Node.js
  
  En resumen, express es un framework web hecho en node, el cual es un entorno de ejecución para javascript construido con el motor de javascript v8 de Chrome. Entre sus funcionalidades destacan la existencia del NPM (Node Package Manager), uno de los gestores de paquetes más grandes a nivel mundial con el que podemos compartir código, dependencias o distribuirlas fácilmente. Gracias al npm, es muy fácil la distribución, ya que en node existe un fichero llamado package.json, donde se almacenan las dependencias del proyecto, y compartiendo únicamente este archivo, con el npm, podremos obtener las dependencias del proyecto original sin necesidad de de grandes tranmisiones de datos. 
  Comenzando el proyecto, importamos una base de datos proporcionada por el profesor (recipes.json) a mongodb.
  Confirmando mis sospechas, hay un MILLÓN de cosas que se pasan por alto OTRA vez. Suponiendo que es un curso para APRENDER, me he tirado 2 horas para poder configurar un simple start server buscando por distintos sitios, instalando módulos necesarios que el cli de vue no incluye (y que tampoco comenta que hay que añadir en ningún momento), etc.
  Aún así, consiguiendo que el proyecto funcione, creamos un servidor básico en localhost, mediante el MVC que hemos visto en SGE en clase, creamos un controlador con métodos para cuando ejecutemos la API Rest tengamos algún valor de prueba de que todo está funcionando por el momento. Para estas pruebas estoy usando la extensión Rester de Firefox que también usamos con Javi en Acceso a Datos.
  Para el modelo que usaremos para conectarnos con MondoDB, instalamos del npm el módulo mongoose, y creamos métodos. Modificando los métodos anteriormente creados en el controlador añadimos las propiedades que queremos que muestre la API Rest cuando conectemos con la base de datos que importamos al principio del proyecto.
  Para la parte de seguridad, utilizamos un token que generamos manualmente en el archivo .env e instalamos otro paquete de npm, jwt-simple, que importamos en nuestros archivos auth.js, y tras crear el controlador con sus métodos, hacemos las comprobaciones de qué queremos devolver y cómo queremos gestionar el acceso dependiendo de si el usuario está autentificado o no.
  Entrando en el front, con el npm descargamos directamente un template de progressive web app. Igual que en la parte de servidor, creamos nuestros componentes .vue con su html, definimos las rutas y tras arrancar tanto cliente como server, se carga el template que descargamos y muestra la información tras conectarse a la base de datos.
  Me parece bastante interesante las alternativas de frameworks para front-end que existen y que facilitan mucho la tarea sin necesidad de "picar" todo el código desde 0, desconozco si express es muy utilizado laboralmente a día de hoy pero lo que sí me pareció muy útil y práctico es el sistema de gestión de paquetes de node.
  
  - Resumen curso Vue.js
      Personalmente, el contenido es bueno, pero creo que se intenta abarcar demasiado y muy rápido en un sólo curso, o al menos es la impresión que me ha dado, ya que siendo alguien que no tiene ningún conocimiento de las tecnologías utilizadas, me he visto perdido en prácticamente toda la duración del curso de Vue. Código que aparece copiado de "algún sitio", ninguna explicación de dónde salen algunos archivos (en algunos casos lo he descubierto en las preguntas que dejan los usuarios, pero la sensación es la misma). Demasiaadas cosas dejadas a libre interpretación para un curso de iniciación desde el principio y que abarque tantos conceptos nuevos que pueden parecer triviales para alguien que se dedica a ello y lleva años trabajando con ellos pero para alguien que está empezando puede llegar (y fue) demasiado frustrante.
 
  
  
  
  
  
  
  
